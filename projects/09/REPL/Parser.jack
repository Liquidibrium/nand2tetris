class Parser {

    constructor Parser new() {
        return this;
    }

    function void log(String line) {
        do Output.printString(line);
        do Output.println();
        return;
    }

    function int precendence(char operator) {
        if (StringFunctions.isAdd(operator) | StringFunctions.isSub(operator)) {
            return 1;
        }
        if (StringFunctions.isMult(operator) | StringFunctions.isDiv(operator)) {
            return 2;
        }
        return 0;
    }
    
    function bool isValidChar(char currentChar) {
        if (StringFunctions.isDigit(currentChar)) {
            return true;
        }
        if (StringFunctions.isOpeningBracket(currentChar)) {
            return true;
        }
        if (StringFunctions.isClosingBracket(currentChar)) {
            return true;
        }
        if (StringFunctions.isOperator(currentChar)) {
            return true;
        }
        if (StringFunctions.isSpace(currentChar)) {
            return true;
        }
        return false;
    }

    function Stack infixToPostfix(String infix) {
        var Stack stack; // operators and ( 
        var Stack postfix; // converted postfix expression
        var int infixLength; // infix expression length 
        var int infixIndex ; // index in infix expression 
        var boolean previousWasOperator;
        var char currentChar;
        var char lastCharFromStack;
        var String lastNumber;
        let infixIndex = 0; 
        let infixLength = infix.length();
        let stack = Stack.new(infixLength);
        let postfix = Stack.new(infixLength);
        let previousWasOperator = false;

        while(infixIndex < infixLength) {
            let currentChar = infix.charAt(infixIndex);
            if(Parser.isValidChar(currentChar)){
                if (StringFunctions.isDigit(currentChar)) { 
                    if ((postfix.size() > 0) & (~previousWasOperator)) {
                        // do  Parser.log("1");
                        do postfix.push("Invalid expression!");
                        return postfix;
                    }
                    let lastNumber = String.new(infixLength);
                    do lastNumber.appendChar(currentChar); 
                    let infixIndex = infixIndex + 1;   
                    if (infixIndex < infixLength) { 
                        let currentChar = infix.charAt(infixIndex); 
                        while ((infixIndex < (infixLength -1)) & StringFunctions.isDigit(currentChar)) {
                            do lastNumber.appendChar(currentChar); 
                            let infixIndex = infixIndex + 1; 
                            let currentChar = infix.charAt(infixIndex); 
                        }
                        if (StringFunctions.isDigit(currentChar)){
                            do lastNumber.appendChar(currentChar);
                        }
                        if (~Parser.isValidChar(currentChar)) {
                            do postfix.push("Invalid expression!");
                            return postfix;
                        }
                    }

                    do postfix.push(lastNumber);
                    let previousWasOperator = false;
                }
                if (StringFunctions.isOpeningBracket(currentChar)) {
                    do stack.push(currentChar);
                }
                if (StringFunctions.isClosingBracket(currentChar)) {
                    if(stack.isEmpty() | previousWasOperator) {
                        // do  Parser.log("2");
                        do postfix.push("Invalid expression!");
                        return postfix;
                    }
                    let lastCharFromStack = stack.pop();
                    while(~ StringFunctions.isOpeningBracket(lastCharFromStack )) {
                        do postfix.push(StringFunctions.charToString(lastCharFromStack));
                        if(stack.isEmpty()){
                            // do  Parser.log("3");
                            do postfix.push("Invalid expression!");
                            return postfix;
                        }       
                        let lastCharFromStack = stack.pop();
                    }

                }
                if (StringFunctions.isOperator(currentChar)) {
                    if (postfix.size() = 0) { //  (-2 + 3) is valid 
                        if(~((currentChar = 45) | (currentChar = 47) )) {// - or +   
                            // do  Parser.log("4");
                            do postfix.push("Invalid expression!");
                            return postfix;
                        } 
                    }
                    while(~stack.isEmpty() & (~(Parser.precendence(currentChar) > Parser.precendence(stack.last())))){
                        do postfix.push(StringFunctions.charToString(stack.pop()));     
                    }
                    do stack.push(currentChar);
                    let previousWasOperator = true;
                }
                if (StringFunctions.isSpace(currentChar)) { 
                   // skip 
                }
                let infixIndex = infixIndex + 1;
            } else {
                // do  Parser.log("5");
                do postfix.push("Invalid expression!");
                return postfix;

            }
        }
        while(~stack.isEmpty()) {
            let currentChar =  stack.pop();
            if(StringFunctions.isOpeningBracket(currentChar)) {
                // do  Parser.log("6");
                do postfix.push("Invalid expression!");
                return postfix;
            }
            do postfix.push(StringFunctions.charToString(currentChar));     
        }
        return postfix;
    }

    function String evaluatePostfix(Stack postfix) {
        var String res;
        var Stack st;
        var int postfixSize;
        var int postfixIndex;
        var String currentStr;
        var int first;
        var int second;
        let postfixSize = postfix.size();
        let res = String.new(postfixSize); // there is no power ^ operator 
        let postfixIndex = 0;
        let st = Stack.new(postfixSize);


        while(postfixIndex < postfixSize) {
            let currentStr = postfix.getItemAt(postfixIndex);
            // do Parser.log(currentStr);
            if (StringFunctions.isOperator( currentStr.charAt(0))) {
                if (st.size() < 2){
                    // if(st.size() = 0){
                    //     do  Parser.log("size 0");
                    // }
                    // if(st.size() = 1){
                    //     do  Parser.log("size 1");
                    // }

                    do  Parser.log("asd1");
                    return "Invalid expression!";
                }
                let second = st.pop();
                let first = st.pop();
                if(currentStr.charAt(0) = 42) { // *
                  do  st.push(first*second);
                } 
                if(currentStr.charAt(0) = 43) { // +
                   do st.push(first+second);
                }
                if(currentStr.charAt(0) = 45) { // -  
                   do st.push(first-second);
                }
                if(currentStr.charAt(0) = 47) { // / 
                   do st.push(first/second);
                }

            } else{
               
               do st.push(currentStr.intValue());
            }
            let postfixIndex = postfixIndex + 1; 
        }
        if (~(st.size() = 1)) {
            do  Parser.log("asd2");
             return "Invalid expression!";
        }
        do res.setInt(st.pop());
        return  res;
    }

    function String evaluate(string expression) {
        var Stack postfix;
        var String result;
        var String last ;
        let postfix = Parser.infixToPostfix(expression); // TODO  
        // do Parser.log(postfix.last());
        if (StringFunctions.stringEquals(postfix.last(), "Invalid expression!")) { // change 
                return postfix.pop();
            }
        let result = Parser.evaluatePostfix(postfix);
        return result;
    }

    /** Disposes this fraction. */
    method void dispose() {
        do Memory.deAlloc(this);  // uses an OS routine to recycle the memory held by the object
        return;
   }
   
}